

# 생성 패턴 (Creational Pattern)
클래스나 객체의 생성과 참조과정에 대한 패턴
## 추상 팩토리(Abstract Factory)
- 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페스를 제공하는 패턴
```java
public class WhiteCarFactory extends DefaultCarFactory{
    @Override
    public Car createCar(){
        // 흰색 차를 만드는 메소드이다.
        Car car = new Car();
        car.setHandle(new WhiteHandle()); 
        car.setWheel(new WhiteWheel());// 만약 차 규격이 바뀌어 WhiteHandle,WhiteWheel 이 아니라 다른 제품으로 바뀐다면?
        return car
    }
}
``` 

```java
//추상 팩토리 패턴 적용하여 규격 변경 문제를 해결 할 수있다.
    public interface CarPartsFactory
    Handle createHandle();
    Wheel createWheel();
    //클라이언트 코드 부분의 수정은 휠과 핸들을 바꾸는 부분에서 생긴다. 따라서 각 파트를 만들어 반환하는 인터페이스를 정의한다.
```

```java
public class WhiteCarPartsFactory implements CarPartsFactory{
    @Override
    public Handle createHandle(){
        return new WhiteHandle();
    }
    @Override
    public Wheel createWheel(){
        return new WhiteWheel();
    }
}
// carPartsFactory를 implements 하여 구체화 한다.
```

```java
//클라이언트 코드
public class WhiteCarFactory extends DefaultCarFactory{
    private final CarPartsFactory carPartsFactory;

    public whiteCarFactory(CarPartsFactory carPartsFactory){
        this.carPartsFactory = carPartsFactory;
    }//생성자로 carPartsFactory 클래스를 구체화한다.
    
    @Override
    public Car createCar(){
        // 흰색 차를 만드는 메소드이다.
        Car car = new Car();
        car.setHandle(carPartsFactory.createHandle()); 
        car.setWheel(carPartsFactory.createWheel());//다른 규격으로 바뀌어도 클라이언트의 코드들(현재 이 코드)이 변경될 필요는 없다.
        return car
    }
}

//만약 WhiteProHandle, WhiteProWheel을 사용하는 걸로 바뀐다면?
//그냥 CarPartsFactory를 구현하는 WhiteCarProPartsFactory를 만들어주면 된다.
//클라이언트 코드에는 생성자를 통해 WhiteCarProPartsFactory의 인스턴스만 넣어주면 된다.
```



## 빌더(Builder)
- 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성하는 패턴
- 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있다.
 ```java
public class Computer { //setter없이 getter만 존재한다. setting은 빌더 클래스가 진행한다.ㅓㅓ
	
    //required parameters
    private String HDD;
    private String RAM;
	
    //optional parameters
    private boolean isGraphicsCardEnabled;
    private boolean isBluetoothEnabled;
	
 
    public String getHDD() {
        return HDD;
    }
 
    public String getRAM() {
        return RAM;
    }
 
    public boolean isGraphicsCardEnabled() {
        return isGraphicsCardEnabled;
    }
 
    public boolean isBluetoothEnabled() {
        return isBluetoothEnabled;
    }
	
    private Computer(ComputerBuilder builder) { //생성자가 private 하기 때문에 객체를 얻으려면 ComputerBuilder클래스를 통해서만 가능하다.
        this.HDD=builder.HDD;
        this.RAM=builder.RAM;
        this.isGraphicsCardEnabled=builder.isGraphicsCardEnabled;
        this.isBluetoothEnabled=builder.isBluetoothEnabled;
    }
	
    //Builder Class
    public static class ComputerBuilder{ //Computer의 내부 클래스로서 빌더 클래스이다.
 
        // required parameters
        private String HDD;
        private String RAM;
 
        // optional parameters
        private boolean isGraphicsCardEnabled;
        private boolean isBluetoothEnabled;
		
        public ComputerBuilder(String hdd, String ram){
            this.HDD=hdd;
            this.RAM=ram;
        }
 
        public ComputerBuilder setGraphicsCardEnabled(boolean isGraphicsCardEnabled) {
            this.isGraphicsCardEnabled = isGraphicsCardEnabled;
            return this;
        }
 
        public ComputerBuilder setBluetoothEnabled(boolean isBluetoothEnabled) {
            this.isBluetoothEnabled = isBluetoothEnabled;
            return this;
        }
		
        public Computer build(){
            return new Computer(this);
        }
 
    }
 
}
 ```

 ```java
 public class TestBuilderPattern {
 
    public static void main(String[] args) {
        Computer comp = new Computer.ComputerBuilder("500 GB", "2 GB")
                .setBluetoothEnabled(true)
                .setGraphicsCardEnabled(true)
                .build();
    }
 
}
 ```
## 팩토리 메소드(Factory Method)
- 객체 생성하는 인터페이스는 미리 정의, but 객체 생성은 서브 클래스로 위임
- 추상 팩토리 패턴과 `구체적인 객체 생성 과정을 추상화한 인터페이스를 제공한다`는 점에서 공통점이지만
- `팩토리 메서드 패턴`은 `팩토리를 구현하는 방법`에 초점
- `추상 팩토리 패턴`은 `팩토리를 사용하는 방법`에 초점
- `추상 팩토리 패턴`은 특정 특정 그룹에 속하는 여러 객체들을 하나의 팩토리로 묶어서 생성할수 있음
## 프로토 타입(Prototype)
## 싱글톤(Singleton)